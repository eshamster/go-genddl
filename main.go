package genddl

import (
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

type Field struct {
	ColumnDef string
}

type Table struct {
	Name       string
	Fields     []Field
	PrimaryKey string
}

func Run(from string) {
	fromdir := filepath.Dir(from)

	var schemadir, outpath, driverName string
	var innerIndexDef, uniqueWithName bool
	flag.StringVar(&schemadir, "schemadir", fromdir, "schema declaretion directory")
	flag.StringVar(&outpath, "outpath", "", "schema target path")
	flag.StringVar(&driverName, "driver", "mysql", "target driver")
	flag.BoolVar(&innerIndexDef, "innerindex", false, "Placement of index definition. If this specified, the definition was placement inner of `create table`")
	flag.BoolVar(&uniqueWithName, "uniquename", false, "Provides a name for the definition of a unique index.")

	flag.Parse()

	var dialect Dialect
	switch driverName {
	case "mysql":
		dialect = MysqlDialect{}
	case "sqlite3":
		dialect = Sqlite3Dialect{}
		// It is not supported by SQLite that placement of index definition inner CREATE TABLE
		innerIndexDef = false
		// It is not supported by SQLite that unique index definition with name
		uniqueWithName = false
	default:
		log.Fatalf("undefined driver name: %s", driverName)
	}

	tables, funcMap, ti, err := retrieveTables(schemadir)
	if err != nil {
		log.Fatalf("parse and retrieve table error: %s", err)
	}

	file, err := os.Create(outpath)
	if err != nil {
		log.Fatal("invalid outpath error:", err)
	}
	tablesMap := map[*ast.StructType]string{}
	var tableNames []string
	for tableName, st := range tables {
		tablesMap[st] = tableName
		tableNames = append(tableNames, tableName)
	}
	sort.Strings(tableNames)
	file.WriteString("-- generated by github.com/mackee/go-genddl. DO NOT EDIT!!!\n")
	for _, tableName := range tableNames {
		st := tables[tableName]
		funcs := funcMap[st]
		tableMap := NewTableMap(tableName, st, funcs, tablesMap, ti, innerIndexDef, uniqueWithName)
		if tableMap != nil {
			file.WriteString("\n")
			tableMap.WriteDDL(file, dialect)
		}
	}

}

var typeNameStructMap = map[string]*ast.StructType{}

func retrieveTables(schemadir string) (map[string]*ast.StructType, map[*ast.StructType][]*ast.FuncDecl, *types.Info, error) {
	path, err := filepath.Abs(schemadir)
	if err != nil {
		return nil, nil, nil, err
	}

	conf := &packages.Config{
		Mode: packages.NeedCompiledGoFiles |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedDeps |
			packages.NeedModule,
	}
	pkgs, err := packages.Load(conf, path)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("retrieveTables: fail to parse from dir: dir=%s, error=%w", schemadir, err)
	}

	if err != nil {
		return nil, nil, nil, err
	}

	var decls []ast.Decl
	var ti *types.Info
	for _, pkg := range pkgs {
		ti = pkg.TypesInfo
		for _, file := range pkg.Syntax {
			decls = append(decls, file.Decls...)
		}
	}

	tables := map[string]*ast.StructType{}
	funcs := []*ast.FuncDecl{}
	funcMap := map[*ast.StructType][]*ast.FuncDecl{}
	for _, decl := range decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			funcs = append(funcs, funcDecl)
		}
		if genDecl, ok := decl.(*ast.GenDecl); ok {
			if genDecl.Doc == nil {
				continue
			}

			for _, comment := range genDecl.Doc.List {
				if strings.HasPrefix(comment.Text, "//+table:") {
					tableName := strings.TrimPrefix(comment.Text, "//+table:")
					tableName = strings.TrimSpace(tableName)
					spec := genDecl.Specs[0]
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						continue
					}

					tables[tableName] = st
					funcMap[st] = make([]*ast.FuncDecl, 0)
					typeNameStructMap[ts.Name.Name] = st
					break
				}
			}
		}
	}

	for _, funcDecl := range funcs {
		if funcDecl.Recv.NumFields() < 0 {
			continue
		}
		if funcDecl.Recv == nil || len(funcDecl.Recv.List) == 0 {
			continue
		}
		recv := funcDecl.Recv.List[0]
		ident, ok := recv.Type.(*ast.Ident)
		if !ok {
			continue
		}
		if ident.Obj == nil || ident.Obj.Decl == nil {
			continue
		}
		ts, ok := ident.Obj.Decl.(*ast.TypeSpec)
		if !ok {
			continue
		}
		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			continue
		}
		if funcs, ok := funcMap[st]; ok {
			funcMap[st] = append(funcs, funcDecl)
		}
	}

	return tables, funcMap, ti, nil
}
